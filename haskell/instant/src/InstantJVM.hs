-- Modification of template generated by BNF Converter
import System.FilePath
import System.IO(stdin, hGetContents, hPutStrLn, stderr)
import System.Environment(getArgs)
import System.Exit
import System.Process
import Text.Printf

import LexInstant
import ParInstant
import SkelInstant
import PrintInstant
import AbsInstant
import ErrM

import JVMData
import JVMTranslator(execJVMTranslate)

printErr = hPutStrLn stderr

type ParseFun a = [Token] -> Err a

run :: ParseFun Program -> FilePath -> IO ()
run parser filePath = do
    printf "Processing %s\n" filePath
    fileContent <- readFile filePath
    case parser (myLexer fileContent) of
        Bad err -> printErr err >> exitFailure
        Ok tree -> case execJVMTranslate (getClassName filePath) tree of
            Left err -> printErr err >> exitFailure
            Right jvmCode -> produceJVMCode filePath jvmCode

jasminPath = "lib" </> "jasmin.jar" :: FilePath

jvmShellCommand :: FilePath -> CreateProcess
jvmShellCommand f =
    (shell $ printf "java -jar %s -d %s %s" jasminPath classPath jvmPath)
    where classPath = takeDirectory f
          jvmPath = f -<.> "j"

getClassName :: FilePath -> String
getClassName = takeBaseName

produceJVMCode :: FilePath -> JVMCode -> IO ()
produceJVMCode filePath jvmCode = do
    writeFile (filePath -<.> "j") (show jvmCode)
    (_, _, _, shellH) <- createProcess $ jvmShellCommand filePath
    exitCode <- waitForProcess shellH
    if exitCode == ExitSuccess
        then return ()
        else printErr "Failed to produce class from JVM code" >> exitFailure

main :: IO ()
main = do
    args <- getArgs
    case args of
        [] -> printErr "Pass file paths to translate to JVM." >> exitFailure
        files -> mapM_ (run pProgram) files





