module SkelLatte where

-- Haskell module generated by the BNF converter

import AbsLatte
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transProgram :: Show a => Program a -> Result
transProgram x = case x of
  Program _ topdefs -> failure x
transTopDef :: Show a => TopDef a -> Result
transTopDef x = case x of
  TopFunDef _ fundef -> failure x
  BaseClassDef _ ident classmembers -> failure x
  ExtClassDef _ ident1 ident2 classmembers -> failure x
transFunDef :: Show a => FunDef a -> Result
transFunDef x = case x of
  FunDef _ type_ ident args block -> failure x
transArg :: Show a => Arg a -> Result
transArg x = case x of
  Arg _ type_ ident -> failure x
transClassMember :: Show a => ClassMember a -> Result
transClassMember x = case x of
  ClassFieldDef _ type_ idents -> failure x
  ClassMethodDef _ fundef -> failure x
transType :: Show a => Type a -> Result
transType x = case x of
  IntType _ -> failure x
  StringType _ -> failure x
  BoolType _ -> failure x
  VoidType _ -> failure x
  ClassType _ ident -> failure x
  ArrayType _ type_ -> failure x
transBlock :: Show a => Block a -> Result
transBlock x = case x of
  StmtBlock _ stmts -> failure x
transStmt :: Show a => Stmt a -> Result
transStmt x = case x of
  SEmpty _ -> failure x
  SBlock _ block -> failure x
  SDecl _ decl -> failure x
  SAssign _ lval exp -> failure x
  SIncr _ lval -> failure x
  SDecr _ lval -> failure x
  SRet _ exp -> failure x
  SRetVoid _ -> failure x
  SIf _ exp stmt -> failure x
  SIfte _ exp stmt1 stmt2 -> failure x
  SWhile _ exp stmt -> failure x
  SFor _ type_ ident exp stmt -> failure x
  SExp _ exp -> failure x
transDecl :: Show a => Decl a -> Result
transDecl x = case x of
  VarDecl _ type_ declitems -> failure x
transDeclItem :: Show a => DeclItem a -> Result
transDeclItem x = case x of
  DeclNoInit _ ident -> failure x
  DeclWithInit _ ident exp -> failure x
transLVal :: Show a => LVal a -> Result
transLVal x = case x of
  LValSelf _ -> failure x
  LValVar _ ident -> failure x
  LValAttr _ lval ident -> failure x
  LValCall _ call -> failure x
  LValMethod _ lval call -> failure x
  LValArrAccess _ lval exp -> failure x
transCall :: Show a => Call a -> Result
transCall x = case x of
  FunCall _ ident exps -> failure x
transExp :: Show a => Exp a -> Result
transExp x = case x of
  ENullObj _ ident -> failure x
  ELVal _ lval -> failure x
  ENewObj _ ident -> failure x
  ENewArr _ type_ exp -> failure x
  EConstant _ constant -> failure x
  ENegate _ opunary exp -> failure x
  EMod _ exp1 opmul exp2 -> failure x
  EAdd _ exp1 opadd exp2 -> failure x
  EComp _ exp1 opcomp exp2 -> failure x
  EAnd _ exp1 exp2 -> failure x
  EOr _ exp1 exp2 -> failure x
transConstant :: Show a => Constant a -> Result
transConstant x = case x of
  CInteger _ integer -> failure x
  CString _ string -> failure x
  CTrue _ -> failure x
  CFalse _ -> failure x
transOpUnary :: Show a => OpUnary a -> Result
transOpUnary x = case x of
  OpNegate _ -> failure x
  OpNot _ -> failure x
transOpMul :: Show a => OpMul a -> Result
transOpMul x = case x of
  OpTimes _ -> failure x
  OpDiv _ -> failure x
  OpMod _ -> failure x
transOpAdd :: Show a => OpAdd a -> Result
transOpAdd x = case x of
  OpPlus _ -> failure x
  OpMinus _ -> failure x
transOpComp :: Show a => OpComp a -> Result
transOpComp x = case x of
  OpLt _ -> failure x
  OpLeq _ -> failure x
  OpGt _ -> failure x
  OpGeq _ -> failure x
  OpEqual _ -> failure x
  OpNeq _ -> failure x

