{-# LANGUAGE FlexibleInstances #-}
module AbsLatte where
import Data.List(intercalate)
import Data.Maybe(fromMaybe)

-- Modification of template generated by BNF Converter
-- Eq instances of datatypes can't be derived, we should omit position field
-- when checking for equality

newtype Ident = Ident { unIdent :: String } deriving (Eq, Ord, Show, Read)
lengthIdent = Ident "length"

type Pos = Maybe (Int, Int)
safePos :: Pos -> (Int, Int)
safePos = fromMaybe (0, 0)

class Description a where
    name :: a -> String
    position :: a -> (Int, Int)
    description :: a -> String
    description s = name s ++ " at " ++ show (position s)


data Program a = Program a [TopDef a] deriving (Show, Read)

instance Eq (Program a) where
    Program _ q == Program _ a = q == a

instance Functor Program where
    fmap f x = case x of
        Program a topdefs -> Program (f a) (map (fmap f) topdefs)


data TopDef a
    = TopFunDef a (FunDef a)
    | BaseClassDef a Ident [ClassMember a]
    | ExtClassDef a Ident Ident [ClassMember a]
    deriving (Show, Read)

instance Eq (TopDef a) where
    TopFunDef _ q == TopFunDef _ a = q == a
    BaseClassDef _ q w == BaseClassDef _ a s = q == a && w == s
    ExtClassDef _ q w e == ExtClassDef _ a s d = q == a && w == s && e == d
    _ == _ = False

instance Description (TopDef Pos) where
    name (TopFunDef _ fun) = name fun
    name (BaseClassDef _ ident _) = unIdent ident
    name (ExtClassDef _ ident _ _) = unIdent ident
    position (TopFunDef pos _) = safePos pos
    position (BaseClassDef pos _ _) = safePos pos
    position (ExtClassDef pos _ _ _) = safePos pos

instance Functor TopDef where
    fmap f x = case x of
        TopFunDef a fundef -> TopFunDef (f a) (fmap f fundef)
        BaseClassDef a ident classmembers -> BaseClassDef (f a) ident (map (fmap f) classmembers)
        ExtClassDef a ident1 ident2 classmembers -> ExtClassDef (f a) ident1 ident2 (map (fmap f) classmembers)


data FunDef a = FunDef
    { __funPos :: a
    , funRetType :: Type a
    , funIdent :: Ident
    , funArgs :: [Arg a]
    , funBlock :: Block a
    } deriving (Show, Read)

instance Eq (FunDef a) where
    FunDef _ q w e r == FunDef _ a s d f = q == a && w == s && e == d && r == f

instance Description (FunDef Pos) where
    name = unIdent . funIdent
    position = safePos . __funPos

instance Functor FunDef where
    fmap f x = case x of
        FunDef a type_ ident args block -> FunDef (f a) (fmap f type_) ident (map (fmap f) args) (fmap f block)


data Arg a = Arg
    { __argPos :: a 
    , argType :: Type a
    , argName :: Ident
    } deriving (Show, Read)

instance Eq (Arg a) where
    Arg _ q w == Arg _ a s = q == a && w == s

instance Description (Arg Pos) where
    name = unIdent . argName
    position = safePos . __argPos

instance Functor Arg where
    fmap f x = case x of
        Arg a type_ ident -> Arg (f a) (fmap f type_) ident


data ClassMember a = ClassFieldDef a (Type a) [Ident] | ClassMethodDef a (FunDef a) deriving (Show, Read)

instance Eq (ClassMember a) where
    ClassFieldDef _ q w == ClassFieldDef _ a s = q == a && w == s
    ClassMethodDef _ q == ClassMethodDef _ a = q == a
    _ == _ = False

instance Description (ClassMember Pos) where
    name (ClassFieldDef _ _ idents) = intercalate ", " (map unIdent idents)
    name (ClassMethodDef _ fun) = name fun
    position (ClassFieldDef pos _ _) = safePos pos
    position (ClassMethodDef pos _) = safePos pos

instance Functor ClassMember where
    fmap f x = case x of
        ClassFieldDef a type_ idents -> ClassFieldDef (f a) (fmap f type_) idents
        ClassMethodDef a fundef -> ClassMethodDef (f a) (fmap f fundef)


data Type a
    = IntType a
    | StringType a
    | BoolType a
    | VoidType a
    | ClassType a Ident
    | ArrayType a (Type a)
    deriving (Show, Read)

intType, stringType, boolType, voidType :: Type Pos
intType = IntType Nothing
stringType = StringType Nothing
boolType = BoolType Nothing
voidType = VoidType Nothing
classType :: String -> Type Pos
classType = ClassType Nothing . Ident
arrayType :: Type Pos -> Type Pos
arrayType = ArrayType Nothing

instance Eq (Type a) where
    IntType _ == IntType _ = True
    StringType _ == StringType _ = True
    BoolType _ == BoolType _ = True
    VoidType _ == VoidType _ = True
    ClassType _ ident1 == ClassType _ ident2 = ident1 == ident2
    ArrayType _ t1 == ArrayType _ t2 = t1 == t2
    _ == _ = False

instance Description (Type Pos) where
    name IntType{} = "int"
    name StringType{} = "string"
    name BoolType{} = "boolean"
    name VoidType{} = "void"
    name (ClassType _ ident) = unIdent ident
    name (ArrayType _ t) = "array of " ++ name t ++ "s"
    position (IntType pos) = safePos pos
    position (StringType pos) = safePos pos
    position (BoolType pos) = safePos pos
    position (VoidType pos) = safePos pos
    position (ClassType pos _) = safePos pos
    position (ArrayType pos _) = safePos pos

nameManyTypes :: [Type Pos] -> String
nameManyTypes = ('[':) . (++"]") . intercalate ", " . map name

instance Functor Type where
    fmap f x = case x of
        IntType a -> IntType (f a)
        StringType a -> StringType (f a)
        BoolType a -> BoolType (f a)
        VoidType a -> VoidType (f a)
        ClassType a ident -> ClassType (f a) ident
        ArrayType a t -> ArrayType (f a) (fmap f t)


data Block a = StmtBlock { __stmtPos :: a, blockStmts :: [Stmt a] } deriving (Show, Read)

instance Eq (Block a) where
    StmtBlock _ q == StmtBlock _ a = q == a

instance Description (Block Pos) where
    name = const "block of statements"
    position = safePos . __stmtPos

instance Functor Block where
    fmap f x = case x of
        StmtBlock a stmts -> StmtBlock (f a) (map (fmap f) stmts)


data Stmt a
    = SEmpty a
    | SBlock a (Block a)
    | SDecl a (Decl a)
    | SAssign a (LVal a) (Exp a)
    | SIncr a (LVal a)
    | SDecr a (LVal a)
    | SRet a (Exp a)
    | SRetVoid a
    | SIf a (Exp a) (Stmt a)
    | SIfte a (Exp a) (Stmt a) (Stmt a)
    | SWhile a (Exp a) (Stmt a)
    | SFor a (Type a) Ident (Exp a) (Stmt a)
    | SExp a (Exp a)
    deriving (Show, Read)

instance Eq (Stmt a) where
    SEmpty _ == SEmpty _ = True
    SBlock _ q == SBlock _ a = q == a
    SDecl _ q == SDecl _ a = q == a
    SAssign _ q w == SAssign _ a s = q == a && w == s
    SIncr _ q == SIncr _ a = q == a
    SDecr _ q == SDecr _ a = q == a
    SRet _ q == SRet _ a = q == a
    SRetVoid _ == SRetVoid _ = True
    SIf _ q w == SIf _ a s = q == a && w == s
    SIfte _ q w e == SIfte _ a s d = q == a && w == s && e == d
    SWhile _ q w == SWhile _ a s = q == a && w == s
    SFor _ q w e r == SFor _ a s d f = q == a && w == s && e == d && r == f
    SExp _ q == SExp _ a = q == a
    _ == _ = False

instance Description (Stmt Pos) where
    name SEmpty{} = "empty statement"
    name (SBlock _ block) = name block
    name (SDecl _ decl) = name decl
    name SAssign{} = "assignment"
    name SIncr{} = "incrementation statement"
    name SDecr{} = "decrementation statement"
    name SRet{} = "return statement"
    name SRetVoid{} = "return statement"
    name SIf{} = "if statement"
    name SIfte{} = "ifte statement"
    name SWhile{} = "while statement"
    name SFor{} = "for statement"
    name SExp{} = "expression statement"
    position (SEmpty pos) = safePos pos
    position (SBlock pos _) = safePos pos
    position (SDecl pos _) = safePos pos
    position (SAssign pos _ _) = safePos pos
    position (SIncr pos _) = safePos pos
    position (SDecr pos _) = safePos pos
    position (SRet pos _) = safePos pos
    position (SRetVoid pos) = safePos pos
    position (SIf pos _ _) = safePos pos
    position (SIfte pos _ _ _) = safePos pos
    position (SWhile pos _ _) = safePos pos
    position (SFor pos _ _ _ _) = safePos pos
    position (SExp pos _) = safePos pos

instance Functor Stmt where
    fmap f x = case x of
        SEmpty a -> SEmpty (f a)
        SBlock a block -> SBlock (f a) (fmap f block)
        SDecl a decl -> SDecl (f a) (fmap f decl)
        SAssign a lval exp -> SAssign (f a) (fmap f lval) (fmap f exp)
        SIncr a lval -> SIncr (f a) (fmap f lval)
        SDecr a lval -> SDecr (f a) (fmap f lval)
        SRet a exp -> SRet (f a) (fmap f exp)
        SRetVoid a -> SRetVoid (f a)
        SIf a exp stmt -> SIf (f a) (fmap f exp) (fmap f stmt)
        SIfte a exp stmt1 stmt2 -> SIfte (f a) (fmap f exp) (fmap f stmt1) (fmap f stmt2)
        SWhile a exp stmt -> SWhile (f a) (fmap f exp) (fmap f stmt)
        SFor a t ident exp stmt -> SFor (f a) (fmap f t) ident (fmap f exp) (fmap f stmt)
        SExp a exp -> SExp (f a) (fmap f exp)


data Decl a = VarDecl
    { __declPos :: a
    , declType :: Type a
    , declItems :: [DeclItem a]
    } deriving (Show, Read)

instance Eq (Decl a) where
    VarDecl _ q w == VarDecl _ a s = q == a && w == s

instance Description (Decl Pos) where
    name (VarDecl _ t _) = "declaration of variable(s) of type " ++ name t
    position (VarDecl pos _ _) = safePos pos
 
instance Functor Decl where
    fmap f x = case x of
        VarDecl a type_ declitems -> VarDecl (f a) (fmap f type_) (map (fmap f) declitems)


data DeclItem a = DeclNoInit a Ident | DeclWithInit a Ident (Exp a) deriving (Show, Read)

instance Eq (DeclItem a) where
    DeclNoInit _ q == DeclNoInit _ a = q == a
    DeclWithInit _ q w == DeclWithInit _ a s = q == a && w == s
    _ == _ = False

instance Functor DeclItem where
    fmap f x = case x of
        DeclNoInit a ident -> DeclNoInit (f a) ident
        DeclWithInit a ident exp -> DeclWithInit (f a) ident (fmap f exp)

instance Description (DeclItem Pos) where
    name (DeclNoInit _ ident) = unIdent ident
    name (DeclWithInit _ ident _) = unIdent ident
    position (DeclNoInit pos _) = safePos pos
    position (DeclWithInit pos _ _) = safePos pos


data LVal a
    = LValSelf a
    | LValVar a Ident
    | LValAttr a (LVal a) Ident
    | LValCall a (Call a)
    | LValMethod a (LVal a) (Call a)
    | LValArrAccess a (LVal a) (Exp a)
    deriving (Show, Read)

instance Eq (LVal a) where
    LValSelf _ == LValSelf _ = True
    LValVar _ q == LValVar _ a = q == a
    LValAttr _ q w == LValAttr _ a s = q == a && w == s
    LValCall _ q == LValCall _ a = q == a
    LValMethod _ q w == LValMethod _ a s = q == a && w == s
    LValArrAccess _ q w == LValArrAccess _ a s = q == a && w == s
    _ == _ = False


instance Description (LVal Pos) where
    name (LValSelf _) = "self reference"
    name (LValVar _ ident) = unIdent ident
    name (LValAttr _ _ ident) = "dot operator to access attribute" ++ unIdent ident
    name (LValCall _ call) = "call of function " ++ name call
    name (LValMethod _ _ call) = "call of method " ++ name call
    name LValArrAccess{} = "array access"
    position (LValSelf pos) = safePos pos
    position (LValVar pos _) = safePos pos
    position (LValAttr pos _ _) = safePos pos
    position (LValCall pos _) = safePos pos
    position (LValMethod pos _ _) = safePos pos
    position (LValArrAccess pos _ _) = safePos pos

instance Functor LVal where
    fmap f x = case x of
        LValSelf a -> LValSelf (f a)
        LValVar a ident -> LValVar (f a) ident
        LValAttr a lval ident -> LValAttr (f a) (fmap f lval) ident
        LValCall a call -> LValCall (f a) (fmap f call)
        LValMethod a lval call -> LValMethod (f a) (fmap f lval) (fmap f call)
        LValArrAccess a lval exp -> LValArrAccess (f a) (fmap f lval) (fmap f exp)


data Call a = FunCall a Ident [Exp a] deriving (Show, Read)

instance Eq (Call a) where
    FunCall _ q w == FunCall _ a s = q == a && w == s

instance Description (Call Pos) where
    name (FunCall _ ident _) = unIdent ident
    position (FunCall pos _ _) = safePos pos

instance Functor Call where
    fmap f x = case x of
        FunCall a ident exps -> FunCall (f a) ident (map (fmap f) exps)


data Exp a
    = ENullObj a Ident
    | ELVal a (LVal a)
    | ENewObj a Ident
    | ENewArr a (Type a) (Exp a)
    | EConstant a (Constant a)
    | ENegate a (OpUnary a) (Exp a)
    | EMod a (Exp a) (OpMul a) (Exp a)
    | EAdd a (Exp a) (OpAdd a) (Exp a)
    | EComp a (Exp a) (OpComp a) (Exp a)
    | EAnd a (Exp a) (Exp a)
    | EOr a (Exp a) (Exp a)
    deriving (Show, Read)

instance Eq (Exp a) where
    ENullObj _ q == ENullObj _ a = q == a
    ELVal _ q == ELVal _ a = q == a
    ENewObj _ q == ENewObj _ a = q == a
    ENewArr _ q w == ENewArr _ a s = q == a && w == s
    EConstant _ q == EConstant _ a = q == a
    ENegate _ q w == ENegate _ a s = q == a && w == s
    EMod _ q w e == EMod _ a s d = q == a && w == s && e == d
    EAdd _ q w e == EAdd _ a s d = q == a && w == s && e == d
    EComp _ q w e == EComp _ a s d = q == a && w == s && e == d
    EAnd _ q w == EAnd _ a s = q == a && w == s
    EOr _ q w == EOr _ a s = q == a && w == s
    _ == _ = False

instance Description (Exp Pos) where
    name (ENullObj _ ident) = "null object of class " ++ unIdent ident
    name (ELVal _ lval) = name lval
    name (ENewObj _ ident) = "new object of class " ++ unIdent ident
    name (ENewArr _ t _) = "new array of type " ++ name t
    name (EConstant _ c) = name c
    name (ENegate _ op _) = name op
    name (EMod _ _ op _) = name op
    name (EAdd _ _ op _) = name op
    name (EComp _ _ op _) = name op
    name EAnd{} = name OpAnd
    name EOr{} = name OpOr
    position (ENullObj pos _) = safePos pos
    position (ELVal pos _) = safePos pos
    position (ENewObj pos _) = safePos pos
    position (ENewArr pos _ _) = safePos pos
    position (EConstant pos _) = safePos pos
    position (ENegate pos _ _) = safePos pos
    position (EMod pos _ _ _) = safePos pos
    position (EAdd pos _ _ _) = safePos pos
    position (EComp pos _ _ _) = safePos pos
    position (EAnd pos _ _) = safePos pos
    position (EOr pos _ _) = safePos pos

instance Functor Exp where
    fmap f x = case x of
        ENullObj a ident -> ENullObj (f a) ident
        ELVal a lval -> ELVal (f a) (fmap f lval)
        ENewObj a ident -> ENewObj (f a) ident
        ENewArr a type_ exp -> ENewArr (f a) (fmap f type_) (fmap f exp)
        EConstant a constant -> EConstant (f a) (fmap f constant)
        ENegate a opunary exp -> ENegate (f a) (fmap f opunary) (fmap f exp)
        EMod a exp1 opmul exp2 -> EMod (f a) (fmap f exp1) (fmap f opmul) (fmap f exp2)
        EAdd a exp1 opadd exp2 -> EAdd (f a) (fmap f exp1) (fmap f opadd) (fmap f exp2)
        EComp a exp1 opcomp exp2 -> EComp (f a) (fmap f exp1) (fmap f opcomp) (fmap f exp2)
        EAnd a exp1 exp2 -> EAnd (f a) (fmap f exp1) (fmap f exp2)
        EOr a exp1 exp2 -> EOr (f a) (fmap f exp1) (fmap f exp2)


data Constant a = CInteger a Integer | CString a String | CTrue a | CFalse a deriving (Show, Read)

instance Eq (Constant a) where
    CInteger _ n == CInteger _ m = n == m
    CString _ s == CString _ t = s == t
    CTrue _ == CTrue _ = True
    CFalse _ == CFalse _ = True
    _ == _ = False

cInteger :: Integer -> Constant Pos
cInteger = CInteger Nothing
cString :: String -> Constant Pos
cString = CString Nothing
cTrue, cFalse :: Constant Pos
cTrue = CTrue Nothing
cFalse = CFalse Nothing

instance Description (Constant Pos) where
    name (CInteger _ n) = show n ++ " constant"
    name (CString _ s) = show s ++ " string constant"
    name CTrue{} = "true constant"
    name CFalse{} = "false constant"
    position (CInteger pos _) = safePos pos
    position (CString pos _) = safePos pos
    position (CTrue pos) = safePos pos
    position (CFalse pos) = safePos pos

instance Functor Constant where
    fmap f x = case x of
        CInteger a integer -> CInteger (f a) integer
        CString a string -> CString (f a) string
        CTrue a -> CTrue (f a)
        CFalse a -> CFalse (f a)


data OpUnary a = OpNegate a | OpNot a deriving (Show, Read)

instance Eq (OpUnary a) where
    OpNegate _ == OpNegate _ = True
    OpNot _ == OpNot _ = True
    _ == _ = False

opNegate, opNot :: OpUnary Pos
opNegate = OpNegate Nothing
opNot = OpNot Nothing

instance Description (OpUnary Pos) where
    name (OpNegate _) = "boolean negation (!)"
    name (OpNot _) = "integer negation (-)"
    position (OpNegate pos) = safePos pos
    position (OpNot pos) = safePos pos

instance Functor OpUnary where
    fmap f x = case x of
        OpNegate a -> OpNegate (f a)
        OpNot a -> OpNot (f a)


data OpMul a = OpTimes a | OpDiv a | OpMod a deriving (Read, Show)

instance Eq (OpMul a) where
    OpTimes _ == OpTimes _ = True
    OpDiv _ == OpDiv _ = True
    OpMod _ == OpMod _ = True
    _ == _ = False

opTimes, opDiv, opMod :: OpMul Pos
opTimes = OpTimes Nothing
opDiv = OpDiv Nothing
opMod = OpMod Nothing

instance Description (OpMul Pos) where
    name (OpTimes _) = "multiplication (*)"
    name (OpDiv _) = "division (/)"
    name (OpMod _) = "modulo (%)"
    position (OpTimes pos) = safePos pos
    position (OpDiv pos) = safePos pos
    position (OpMod pos) = safePos pos

instance Functor OpMul where
    fmap f x = case x of
        OpTimes a -> OpTimes (f a)
        OpDiv a -> OpDiv (f a)
        OpMod a -> OpMod (f a)


data OpAdd a = OpPlus a | OpMinus a deriving (Read, Show)

opPlus, opMinus :: OpAdd Pos
opPlus = OpPlus Nothing
opMinus = OpMinus Nothing

instance Eq (OpAdd a) where
    OpPlus _ == OpPlus _ = True
    OpMinus _ == OpMinus _ = True
    _ == _ = False

instance Description (OpAdd Pos) where
    name (OpPlus _) = "addition (+)" -- no context on whether it is integer addition or string concatenation
    name (OpMinus _) = "subtraction (-)"
    position (OpPlus pos) = safePos pos
    position (OpMinus pos) = safePos pos

instance Functor OpAdd where
    fmap f x = case x of
        OpPlus a -> OpPlus (f a)
        OpMinus a -> OpMinus (f a)


data OpComp a = OpLt a | OpLeq a | OpGt a | OpGeq a | OpEqual a | OpNeq a deriving (Read, Show)

instance Eq (OpComp a) where
    OpLt _ == OpLt _ = True
    OpLeq _ == OpLeq _ = True
    OpGt _ == OpGt _ = True
    OpGeq _ == OpGeq _ = True
    OpEqual _ == OpEqual _ = True
    OpNeq _ == OpNeq _ = True
    _ == _ = False

opLt, opLeq, opGt, opGeq, opEqual, opNeq :: OpComp Pos
opLt = OpLt Nothing
opLeq = OpLeq Nothing
opGt = OpGt Nothing
opGeq = OpGeq Nothing
opEqual = OpEqual Nothing
opNeq = OpNeq Nothing

instance Description (OpComp Pos) where
    name (OpLt _) = "comparison (<)"
    name (OpLeq _) = "comparison (<=)"
    name (OpGt _) = "comparison (>)"
    name (OpGeq _) = "comparison (>=)"
    name (OpEqual _) = "equality check (==)"
    name (OpNeq _) = "equality check (!=)"
    position (OpLt pos) = safePos pos
    position (OpLeq pos) = safePos pos
    position (OpGt pos) = safePos pos
    position (OpGeq pos) = safePos pos
    position (OpEqual pos) = safePos pos
    position (OpNeq pos) = safePos pos

instance Functor OpComp where
    fmap f x = case x of
        OpLt a -> OpLt (f a)
        OpLeq a -> OpLeq (f a)
        OpGt a -> OpGt (f a)
        OpGeq a -> OpGeq (f a)
        OpEqual a -> OpEqual (f a)
        OpNeq a -> OpNeq (f a)


data OpLog = OpAnd | OpOr deriving (Eq, Ord, Show, Read)

instance Description OpLog where
    name OpAnd = "logical conjunction (&&)"
    name OpOr = "logical disjunction (||)"
    position = const (0, 0)